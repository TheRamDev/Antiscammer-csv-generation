<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scam Label Chatbot — Public + Gist Safe Mode</title>
  <style>
    :root{
      --bg:#0f172a;--panel:#111827;--muted:#94a3b8;--txt:#e5e7eb;--ring:#263247;--accent:#22d3ee;--accent2:#a78bfa;--warn:#f59e0b;--err:#ef4444;--ok:#22c55e
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 600px at 0% -10%, #1b2950 0%, #0b1220 40%, #0b1220 100%);color:var(--txt);font-family:system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Arial}
    header{position:sticky;top:0;z-index:3;display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 16px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,0));backdrop-filter:blur(6px);border-bottom:1px solid var(--ring)}
    header h1{margin:0;font-size:18px;letter-spacing:.2px}
    .badges{display:flex;gap:8px;flex-wrap:wrap}
    .badge{font-size:12px;padding:4px 8px;border:1px solid var(--ring);border-radius:999px;background:#0c1426;color:var(--muted)}
    .badge.ok{color:#bbf7d0;border-color:#124124;background:#0b1a12}
    .badge.warn{color:#fff7ed;border-color:#573b10;background:#2a1e0c}
    .badge.err{color:#fee2e2;border-color:#4a1417;background:#2a0f12}

    main{padding:16px;display:grid;grid-template-columns:1fr 360px;gap:16px}
    @media (max-width:1000px){main{grid-template-columns:1fr}}

    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid var(--ring);border-radius:14px}
    .chat{min-height:60svh;display:grid;grid-template-rows:1fr auto}
    .msgs{padding:16px;overflow:auto;display:flex;flex-direction:column;gap:10px}
    .msg{display:flex;gap:10px}
    .bubble{max-width:85%;padding:12px 14px;border-radius:14px;border:1px solid #1b2a48;background:#0d162a}
    .user .bubble{border-color:#1f335e;background:#0f1a33}
    .bot .bubble{border-color:#1b2b48;background:#0c182a}

    .composer{display:grid;grid-template-columns:1fr auto auto auto;gap:10px;padding:12px;border-top:1px solid var(--ring);background:#0b1220;border-radius:0 0 14px 14px}
    input,select,button{padding:10px 12px;border-radius:10px;border:1px solid #1a2441;background:#0e172c;color:var(--txt)}
    button{cursor:pointer}
    button.primary{border-color:#21426e}
    button:hover{filter:brightness(1.1)}

    aside{display:grid;gap:14px;align-content:start}
    .pad{padding:12px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px 6px;border-bottom:1px dashed #203152;vertical-align:top}
    .hint{color:var(--muted);font-size:12px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .right{margin-left:auto}
  </style>
</head>
<body>
  <header>
    <h1>Scam Label Chatbot</h1>
    <div class="badges">
      <span id="modeBadge" class="badge warn">mode: local (no gist)</span>
      <span id="authBadge" class="badge warn">auth: none</span>
      <span id="statusBadge" class="badge">idle</span>
    </div>
    <div class="row">
      <button id="setTokenBtn" title="Paste a token at runtime (kept in session only)">Set token</button>
      <button id="exportCsvTop" class="primary">Export CSV</button>
    </div>
  </header>

  <main>
    <section class="card chat">
      <div id="msgs" class="msgs" role="log" aria-live="polite"></div>
      <div class="composer">
        <input id="text" type="text" placeholder="Type here…" autocomplete="off" />
        <select id="label">
          <option value="not_scam" selected>not_scam</option>
          <option value="scam">scam</option>
        </select>
        <button id="send" class="primary">Send</button>
        <button id="quickScam">Flag scam</button>
      </div>
    </section>

    <aside>
      <section class="card pad">
        <h3 style="margin:0 0 8px">Data</h3>
        <div class="row" style="margin-bottom:8px">
          <button id="exportCsv">Export CSV</button>
          <button id="refresh">Refresh</button>
          <button id="clearLocal">Clear local cache</button>
        </div>
        <div class="hint">CSV cols: <span class="mono">text,label,ts</span>. Everyone can add; writes to Gist require a token. You can pass config via URL, e.g. <span class="mono">?gist=GIST_ID&file=scam_dataset.json</span>.</div>
      </section>

      <section class="card pad">
        <h3 style="margin:0 0 8px">Rows</h3>
        <table id="rowsTbl">
          <thead><tr><th>#</th><th>label</th><th>text</th><th></th></tr></thead>
          <tbody></tbody>
        </table>
      </section>

      <section class="card pad">
        <h3 style="margin:0 0 8px">Self‑tests</h3>
        <div class="row">
          <button id="runTests">Run tests</button>
        </div>
        <pre id="testOut" class="mono" style="white-space:pre-wrap;margin-top:8px;max-height:180px;overflow:auto"></pre>
        <div class="hint">These tests ensure the page doesn’t crash when Gist config is missing and that CSV/export behave.</div>
      </section>

      <section class="card pad">
        <h3 style="margin:0 0 8px">About</h3>
        <p class="hint">Designed to work on static hosts (GitHub Pages). 
        <br/>Modes: <b>local</b> (no network) or <b>gist</b> (read without token; write requires token). Token is stored in <b>sessionStorage</b> only.</p>
      </section>
    </aside>
  </main>

  <script>
    // =============================
    // Config + utilities
    // =============================
    const qs = new URLSearchParams(location.search);
    const CONFIG = {
      gistId: qs.get('gist') || '',
      fileName: qs.get('file') || 'scam_dataset.json',
    };

    const state = {
      data: [],
      mode: CONFIG.gistId ? 'gist' : 'local',
      token: sessionStorage.getItem('GIST_TOKEN') || '',
    };

    const el = (q, ctx=document)=>ctx.querySelector(q);
    const msgs = el('#msgs');
    const rowsBody = el('#rowsTbl tbody');
    const modeBadge = el('#modeBadge');
    const authBadge = el('#authBadge');
    const statusBadge = el('#statusBadge');

    function setStatus(txt, kind=''){
      statusBadge.textContent = txt;
      statusBadge.className = 'badge ' + (kind||'');
    }
    function setModeBadges(){
      modeBadge.textContent = `mode: ${state.mode}${state.mode==='gist' ? ` (file=${CONFIG.fileName})` : ''}`;
      modeBadge.className = 'badge ' + (state.mode==='gist' ? 'ok' : 'warn');
      authBadge.textContent = state.token ? 'auth: token set' : 'auth: none';
      authBadge.className = 'badge ' + (state.token ? 'ok' : 'warn');
    }

    function escapeHtml(str){
      return String(str).replace(/[&<>\"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;','\'':'&#39;'}[s]));
    }

    function addMsg(role, text){
      const wrap = document.createElement('div');
      wrap.className = `msg ${role}`;
      const b = document.createElement('div');
      b.className = 'bubble';
      b.innerHTML = escapeHtml(text);
      wrap.append(b);
      msgs.append(wrap);
      msgs.scrollTop = msgs.scrollHeight;
    }

    function toCSV(rows){
      const esc = v => '"' + String(v).replace(/"/g,'""') + '"';
      const head = ['text','label','ts'];
      const body = rows.map(r => [esc(r.text), esc(r.label), esc(r.ts)].join(','));
      return head.join(',') + '\n' + body.join('\n');
    }

    function downloadCsv(){
      const csv = toCSV(state.data);
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'scam_dataset.csv'; a.click();
      URL.revokeObjectURL(url);
    }

    // =============================
    // Local storage fallback
    // =============================
    const LKEY = 'scam_rows_v2';
    function loadLocal(){
      try{ state.data = JSON.parse(localStorage.getItem(LKEY)||'[]') }catch{ state.data = [] }
    }
    function saveLocal(){ localStorage.setItem(LKEY, JSON.stringify(state.data)) }

    // =============================
    // Gist API helpers (read works w/o token; write needs token)
    // =============================
    async function gistRead(){
      if(!CONFIG.gistId){ throw new Error('No Gist ID provided') }
      const res = await fetch(`https://api.github.com/gists/${CONFIG.gistId}`);
      if(!res.ok){ throw new Error('Gist fetch failed: ' + res.status) }
      const gist = await res.json();
      const files = gist && gist.files ? gist.files : {};
      const file = files[CONFIG.fileName];
      // If file missing, treat as empty list
      const content = file && typeof file.content === 'string' ? file.content : '[]';
      return JSON.parse(content);
    }

    async function gistWrite(){
      if(!CONFIG.gistId) throw new Error('No Gist ID provided');
      if(!state.token) throw new Error('No token set for writing');
      const res = await fetch(`https://api.github.com/gists/${CONFIG.gistId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${state.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ files: { [CONFIG.fileName]: { content: JSON.stringify(state.data, null, 2) } } })
      });
      if(!res.ok){ throw new Error('Gist write failed: ' + res.status) }
      return true;
    }

    // =============================
    // Render table
    // =============================
    function renderRows(){
      rowsBody.innerHTML = '';
      state.data.forEach((r,i)=>{
        const tr = document.createElement('tr');
        const c1 = document.createElement('td'); c1.textContent = i+1;
        const c2 = document.createElement('td'); c2.textContent = r.label;
        const c3 = document.createElement('td'); c3.innerHTML = `<pre style="margin:0;white-space:pre-wrap">${escapeHtml(r.text)}</pre>`;
        const c4 = document.createElement('td');
        const sel = document.createElement('select'); sel.innerHTML = '<option value="not_scam">not_scam</option><option value="scam">scam</option>';
        sel.value = r.label; sel.onchange = ()=>{ r.label = sel.value; persist('edit') };
        const rm = document.createElement('button'); rm.textContent = 'remove'; rm.onclick = ()=>{ state.data.splice(i,1); persist('remove') };
        c4.append(sel, rm);
        tr.append(c1,c2,c3,c4); rowsBody.append(tr);
      })
    }

    // =============================
    // Persistence coordinator
    // =============================
    async function persist(reason='add'){
      try{
        if(state.mode==='gist'){
          saveLocal(); // keep a cache for resilience
          if(!state.token){ setStatus('saved locally (no token)', 'warn'); renderRows(); return }
          await gistWrite();
          setStatus('saved to gist', 'ok');
        } else {
          saveLocal();
          setStatus('saved locally', 'ok');
        }
        renderRows();
      }catch(err){
        console.error(err);
        setStatus('save error — see console', 'err');
      }
    }

    // =============================
    // Load on start
    // =============================
    async function bootstrap(){
      setModeBadges();
      if(state.mode==='gist'){
        try{
          state.data = await gistRead();
          setStatus('loaded from gist', 'ok');
          // also seed local cache
          saveLocal();
        }catch(err){
          console.warn('Gist read failed; falling back to local:', err);
          loadLocal();
          setStatus('gist read failed — using local cache', 'warn');
        }
      }else{
        loadLocal();
        setStatus('loaded local', '');
      }
      renderRows();
      addMsg('bot', 'Welcome! Type, label, and Send. Export CSV any time. URL config: ?gist=ID&file=name.json');
    }

    // =============================
    // Bot reply (placeholder)
    // =============================
    function botReply(t){
      const s = String(t).toLowerCase();
      const flags = [/free\s*(robux|nitro|gems|coins)/, /(crypto|usdt|btc).*\b(doubl|multipl)/, /verify\s*code|2fa/];
      if(flags.some(rx=>rx.test(s))) return '⚠️ Looks scammy. Avoid links and do not share codes.';
      if(/^(hi|hello|hey)\b/.test(s)) return 'Hi! Add a label, then Export CSV.';
      return 'Noted. Labeled + stored.';
    }

    // =============================
    // UI wiring
    // =============================
    el('#send').onclick = handleSend;
    el('#text').addEventListener('keydown',e=>{ if(e.key==='Enter'&&!e.shiftKey){ e.preventDefault(); handleSend() } });
    el('#quickScam').onclick = ()=>{ const v = el('#text').value.trim(); if(!v) return; el('#label').value='scam'; handleSend() };
    el('#exportCsv').onclick = downloadCsv; el('#exportCsvTop').onclick = downloadCsv;
    el('#refresh').onclick = bootstrap;
    el('#clearLocal').onclick = ()=>{ localStorage.removeItem(LKEY); setStatus('local cache cleared'); };
    el('#setTokenBtn').onclick = async ()=>{
      const t = prompt('Paste a GitHub token with Gist edit scope (never store in code). It will be kept in sessionStorage until you close the tab.');
      if(typeof t==='string'){
        state.token = t.trim();
        if(state.token){ sessionStorage.setItem('GIST_TOKEN', state.token) } else { sessionStorage.removeItem('GIST_TOKEN') }
        setModeBadges();
      }
    };

    async function handleSend(){
      const text = el('#text').value.trim();
      const label = el('#label').value;
      if(!text) return;
      addMsg('user', text);
      el('#text').value='';
      setTimeout(()=>addMsg('bot', botReply(text)), 80);
      state.data.push({ text, label, ts: Date.now() });
      await persist('add');
    }

    // =============================
    // Tests (run in browser)
    // =============================
    el('#runTests').onclick = runTests;
    function assert(name, cond){
      return (cond? '✓':'✗') + ' ' + name + (cond?'':' (failed)');
    }
    function runTests(){
      const out = [];
      // Test 1: CSV escape
      const sample = [{text:'He said "free"',label:'scam',ts:1}];
      const csv = toCSV(sample);
      out.push(assert('CSV has header', /^text,label,ts/.test(csv)));
      out.push(assert('CSV quotes inner quotes', csv.includes('"He said ""free"""')));

      // Test 2: gistRead safe when files undefined
      const fake = { files: undefined };
      let safeOk = false;
      try{ const content = (fake && fake.files && fake.files['x'] && fake.files['x'].content) || '[]'; JSON.parse(content); safeOk = true }catch{ safeOk=false }
      out.push(assert('Safe parse when files undefined', safeOk));

      // Test 3: no token write -> handled
      const oldMode = state.mode, oldToken = state.token;
      state.mode='gist'; state.token='';
      let writeBlocked = false;
      try{ await gistWrite(); }catch(e){ writeBlocked = /No token/.test(String(e)) }
      state.mode=oldMode; state.token=oldToken;
      out.push(assert('Gist write blocked without token', writeBlocked));

      // Test 4: local cache roundtrip
      const before = JSON.stringify(state.data);
      saveLocal(); loadLocal();
      out.push(assert('Local cache roundtrip', before===JSON.stringify(state.data)));

      el('#testOut').textContent = out.join('\n');
    }

    // Start
    setModeBadges();
    bootstrap();
  </script>
</body>
</html>
